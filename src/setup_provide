#!/usr/bin/env python3

import argparse
import os
import re
import shutil
import subprocess
import sys
from datetime import datetime, timedelta
from itertools import chain
from pathlib import Path
from time import sleep

from gradescope_web import GradescopeSession
from termcolor import colored

COURSE = 15
BASEDIR = Path("/comp/" + str(COURSE) + "/grading")
ASSIGN_CONF = BASEDIR / "assignments.conf"
GROUP = "grade15"
MAXLATEDAYS = 2


def main(
    assign, duedate, duetime, minfiles, files, reqFiles, submissions, status
):
    userConfig = {
        k: v
        for k, v in locals().items() if v is not None and k != "reqFiles"
    }
    os.umask(0o002)

    TESTSET = BASEDIR / ("screening/testsets/" + assign)
    EXCEPTIONS = BASEDIR / (assign + "/exceptions.conf")

    foundConfig, (start, end) = find_assignment(assign)
    newConfig = {
        **{
            "prepare": "screening/bin/check_files"
        },
        **foundConfig,
        **userConfig
    }

    showHeader("Configuring assignment.conf")

    add_assignment(newConfig, start, end)
    launch_editor(ASSIGN_CONF, start)

    showHeader("Setting up legacy testing folders")
    setupLegacyFolders(assign)

    showHeader("Setting up gradescope assignment")
    courseId, assignId = getGradescopeIDs(assign, duedate, duetime)

    showHeader("Configuring testset")
    create_testset(assign, reqFiles, courseId, assignId)
    launch_editor(TESTSET)

    showHeader("Running prozac")
    prozac(COURSE, assign)

    add_exception(EXCEPTIONS)


def showHeader(string):
    """
        Prints out a formatted section header.
        (Formatting is omitted if stdout isn't a tty)
    """
    string = "\n* " + string
    if sys.stdout.isatty():
        string = colored(string.replace(" ", "_"), attrs=['bold', 'underline'])
    print(string, end="\n\n")


def add_exception(EXCEPTIONS):
    """
        adds exception for mkorma01 account to allow for testing
    """
    with EXCEPTIONS.open("a") as f:
        f.write(
            "login=mkorma01 status=on duedate=12/25 duetime=11:59pm submissions=10000 "
        )


def create_testset(assign, files, courseId, assignId):
    """
        Copies template testset into testset directory.
        Replaces some placeholder strings in template with appropriate
        values
    """
    new_testset = BASEDIR / ("screening/testsets/" + assign)
    shutil.copy2(
        *map(
            str,
            (BASEDIR / "tests/setup-provide/bin/setup_testset", new_testset)
        )
    )
    shutil.chown(str(new_testset), group=GROUP)
    new_testset.chmod(0o770)
    # edit testset
    replacements = [
        arg for key, val in {
            "ASSIGN_NAME": assign,
            "REQUIRED_FILES": ' '.join(files),
            "COURSE_ID": courseId,
            "ASSIGNMENT_ID": assignId
        }.items() for arg in ['-e', 's/{0}/{1}/g'.format(key, val)]
    ]
    subprocess.run(["sed", "-i", *replacements, str(new_testset)])


def getEntireConfig(fileIterator):
    """
        Grabs all lines from iterator until first non continued line
        returns (endingLineno, lines)
    """
    lineno, line = next(fileIterator)
    if not line.endswith("\\\n"):
        return lineno, line.rstrip()
    end, suffix = getEntireConfig(fileIterator)
    return end, line + suffix


def find_assignment(assign):
    """
        Finds the assignment if it exists and returns the config.
        Always returns last found assignment. 
        Ex. in assignment.conf:
            assign=hw4 submissions=5 duedate=3/11
            assign=hw4 submissions=9999 duedate=12/25 <--- returned

        Returns (assignDict, (    start,       end))   if found
                (        {}, (eofLineno, eofLineno))   if not found
    """
    found_assignment = None
    pattern = "assign=" + assign
    with ASSIGN_CONF.open() as f:
        fileIter = enumerate(f, 1)
        for lineNum, line in fileIter:
            if line.isspace():
                continue

            endNum, conf = getEntireConfig(chain([(lineNum, line)], fileIter))

            if re.search(r'\b' + pattern + r'\b', conf):
                found_assignment = (config2dict(conf), (lineNum, endNum))

    eofNum = max(lineNum, endNum) + 1
    return found_assignment if found_assignment else ({}, (eofNum, eofNum))


def config2dict(config):
    config = config.replace("\\\n", " ")
    return dict(field.split("=", 1) for field in config.split())


def dict2config(configDict):
    updated_config = ""
    for field, value in sorted(configDict.items(), key=lambda x: x[0]):
        if field == "prepare":
            updated_config += "\\\n\t"
        updated_config += field + "=" + value + " "
    return updated_config


def launch_editor(path, line_num=0):
    """
        launches a text editor, returns after file is closed.
    """
    print("Opening {}.\n\nEdit file if needed, close to continue.".format(path))

    cmd = ["code", "--wait", "--goto", '{}:{}'.format(path, line_num)]

    if not shutil.which("code"):
        sleep(3)
        cmd = ["vim", "+" + str(line_num), path]

    subprocess.run(cmd)


def add_assignment(configDict, start=None, end=None):
    """
        adds the assignment to assignments.conf
    """
    config = dict2config(configDict)

    # Assignment exists, so we are overwritting with our new config
    with ASSIGN_CONF.open() as f:
        data = f.readlines()
    with ASSIGN_CONF.open("w") as f:
        f.writelines(data[0:start - 1])
        # Add newline if file doesn't end with a newline
        if start > len(data) and not data[-1].endswith("\n"):
            f.write("\n")
        f.write(config + "\n")
        f.writelines(data[end:])


def setupLegacyFolders(assign):
    """
        Sets up a list of folders that are used by 
        /comp/15/grading/gtools/grade

        Not currently in use, but set up as a fallback
    """
    testdir = BASEDIR / ('tests/' + assign)
    for x in ["bin", "copy", "cpp", "input", "output", "makefile"]:
        (testdir / x).mkdir(parents=True, exist_ok=True)
        shutil.chown(str(testdir / x), group=GROUP)
    shutil.chown(str(testdir), group=GROUP)


def prozac(course, assign):
    """
        Runs prozac, which sets up /comp/15/grading/HWID and assures
        correct permissions
    """
    subprocess.run(["prozac", "comp" + str(course), assign])


def verifyDateTime(dtFormat):
    def verifier(value):
        try:
            datetime.strptime(value, dtFormat)
            return value
        except ValueError:
            pass
        raise argparse.ArgumentTypeError(
            value + " doesn't match format " + dtFormat
        )

    return verifier


def getGradescopeIDs(assign, duedate, duetime):
    g = GradescopeSession()
    dueDateTime = datetime.strptime(duedate + " " + duetime,
                                    '%m/%d %H:%M').replace(
                                        year=datetime.now().year
                                    )

    hideUntil = dueDateTime + timedelta(days=MAXLATEDAYS)

    # TODO: Refactor out name and semester (no hard coding)
    course = next(
        (
            c for c in g.classes if c.role == "instructor" and
            c.name == "Comp 15" and c.semester == "Fall 2020"
        ), None
    )

    if not course:
        raise ValueError("You don't have access to course on Gradescope")

    assignment = next((a for a in course.assignments if a.name == assign), None)

    if not assignment:
        assignment = course.create_assignment(
            title=assign,
            totalPoints=0,
            releaseDate=hideUntil,
            dueDate=hideUntil,
            manualGrading=True,
            memoryLimit=6144,
            autograderTimeout=600
        )

    return course.id, assignment.id


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Helps you set up an assignment'
    )
    requiredArgs = parser.add_argument_group('required arguments')
    requiredArgs.add_argument(
        '-a', required=True, dest='assign', help='Assignment name e.g. hw1'
    )
    requiredArgs.add_argument(
        '-d',
        required=True,
        dest='duedate',
        help='Date in form of MM/DD e.g. 12/25',
        type=verifyDateTime("%m/%d")
    )
    requiredArgs.add_argument(
        '-t',
        required=True,
        dest='duetime',
        help='Time in form of HH:MM e.g. 15:00',
        type=verifyDateTime("%H:%M")
    )
    group = parser.add_mutually_exclusive_group(required=False)
    group.add_argument('--minfiles', help="Minimum number of files required")
    group.add_argument(
        '--numfiles', dest='files', help="Number of files required"
    )
    parser.add_argument(
        '--status',
        help="Status of assignment. Default is 'off'",
        default='off',
        choices=[
            "on",
            "off",
        ]
    )
    parser.add_argument('reqFiles', metavar='files', nargs='*',\
                        help='Names of required files.')
    parser.add_argument('-ns', dest='submissions', default='5',\
                        help='Number of submissions allowed per student. Default: 5.')

    main(**vars(parser.parse_args()))
