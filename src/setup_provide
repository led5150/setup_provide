#!/usr/bin/python3

import argparse
import os
import re
import shutil
import subprocess
from datetime import datetime, timedelta
from itertools import chain
from pathlib import Path
from time import sleep

from gradescope_web import GradescopeSession

COURSE = 15
BASEDIR = Path(f"/comp/{COURSE}/grading")
ASSIGN_CONF = BASEDIR / "assignments.conf"
GROUP = "grade15"
MAXLATEDAYS = 2


def main(
    assign, duedate, duetime, minfiles, files, reqFiles, submissions, status
):
    userConfig = {
        k: v
        for k, v in locals().items() if v is not None and k != "reqFiles"
    }
    os.umask(0o002)

    TESTSET = BASEDIR / f"screening/testsets/{assign}"
    EXCEPTIONS = BASEDIR / f"{assign}/exceptions.conf"

    foundConfig, (start, end) = find_assignment(assign)
    newConfig = {
        **{
            "prepare": "screening/bin/check_files"
        },
        **foundConfig,
        **userConfig
    }

    add_assignment(newConfig, start, end)
    launch_editor(ASSIGN_CONF, start)

    setupLegacyFolders(assign)
    courseId, assignId = getGradescopeIDs(assign, duedate, duetime)
    create_testset(assign, reqFiles, courseId, assignId)
    launch_editor(TESTSET)
    prozac(COURSE, assign)
    add_exception(EXCEPTIONS)


def add_exception(EXCEPTIONS):
    """
    adds exception for mkorma01 account to allow for testing
    """
    with open(f"{EXCEPTIONS}", "a") as f:
        f.write(
            "login=mkorma01 status=on duedate=12/25 duetime=11:59pm submissions=10000 "
        )


def create_testset(assign, files, courseId, assignId):
    """
    copies setup_testset to the assignment folder and makes the appropriate edits
    adding in required files passed in by user and updating the assignment name
    """
    new_testset = BASEDIR / f"screening/testsets/{assign}"

    shutil.copy2(BASEDIR / "tests/setup-provide/bin/setup_testset", new_testset)
    shutil.chown(new_testset, group=GROUP)
    new_testset.chmod(0o770)
    # edit testset
    replacements = [
        arg for key, val in {
            "ASSIGN_NAME": assign,
            "REQUIRED_FILES": ' '.join(files),
            "COURSE_ID": courseId,
            "ASSIGNMENT_ID": assignId
        }.items() for arg in ['-e', f's/{key}/{val}/g']
    ]
    subprocess.run(["sed", "-i", *replacements, f"{new_testset}"])


def getEntireConfig(fileIterator):
    """
        Grabs all lines from iterator until first non continued line
        returns (endingLineno, lines)
    """
    lineno, line = next(fileIterator)
    if not line.endswith("\\\n"):
        return lineno, line.rstrip()
    end, suffix = getEntireConfig(fileIterator)
    return end, line + suffix


def find_assignment(assign):
    """
        Finds the assignment if it exists and returns the config.
        Always returns last found assignment. 
        Ex. in assignment.conf:
            assign=hw4 submissions=5 duedate=3/11
            assign=hw4 submissions=9999 duedate=12/25 <--- returned

        Returns (assignDict, (    start,       end))   if found
                (        {}, (eofLineno, eofLineno))   if not found
    """
    found_assignment = None
    pattern = "assign=" + assign
    with open(ASSIGN_CONF) as f:
        fileIter = enumerate(f, 1)
        for lineNum, line in fileIter:
            if line.isspace():
                continue

            endNum, conf = getEntireConfig(chain([(lineNum, line)], fileIter))

            if re.search(r'\b' + pattern + r'\b', conf):
                found_assignment = (config2dict(conf), (lineNum, endNum))

    eofNum = max(lineNum, endNum) + 1
    return found_assignment if found_assignment else ({}, (eofNum, eofNum))


def config2dict(config):
    config = config.replace("\\\n", " ")
    return dict(field.split("=", 1) for field in config.split())


def dict2config(configDict):
    updated_config = ""
    for field, value in sorted(configDict.items(), key=lambda x: x[0]):
        if field == "prepare":
            updated_config += "\\\n\t"
        updated_config += field + "=" + value + " "
    return updated_config


def launch_editor(path, line_num=0):
    """
    launches vim and has user verify and save file.
    """
    print(f'Opening "{path}". Close file to continue.')

    cmd = ["code", "--wait", "--goto", f'{path}:{line_num}']

    if not shutil.which("code"):
        sleep(3)
        cmd = ["vim", f"+{line_num}", path]

    subprocess.run(cmd)


def add_assignment(configDict, start=None, end=None):
    """
    adds the assignment to assignments.conf
    """
    config = dict2config(configDict)

    # Assignment exists, so we are overwritting with our new config
    with ASSIGN_CONF.open() as f:
        data = f.readlines()
    with ASSIGN_CONF.open("w") as f:
        f.writelines(data[0:start - 1])
        # Add newline if file doesn't end with a newline
        if start > len(data) and not data[-1].endswith("\n"):
            f.write("\n")
        f.write(config + "\n")
        f.writelines(data[end:])


def setupLegacyFolders(assign):
    """
        Sets up a list of folders that are used by 
        /comp/15/grading/gtools/grade

        Not currently in use, but set up as a fallback
    """
    testdir = BASEDIR / f'tests/{assign}'
    for x in ["bin", "copy", "cpp", "input", "output", "makefile"]:
        (testdir / x).mkdir(parents=True, exist_ok=True)
        shutil.chown(testdir / x, group=GROUP)
    shutil.chown(testdir, group=GROUP)


def prozac(course, assign):
    """
        Runs prozac, which sets up /comp/15/grading/HWID and assures
        correct permissions
    """
    subprocess.run(["prozac", f"comp{course}", assign])


def verifyDateTime(dtFormat):
    def verifier(value):
        try:
            datetime.strptime(value, dtFormat)
            return value
        except ValueError:
            pass
        raise argparse.ArgumentTypeError(
            f"{value} doesn't match format {dtFormat}"
        )

    return verifier


def getGradescopeIDs(assign, duedate, duetime):
    g = GradescopeSession()
    dueDateTime = datetime.strptime(f'{duedate} {duetime}',
                                    '%m/%d %H:%M').replace(
                                        year=datetime.now().year
                                    )

    hideUntil = dueDateTime + timedelta(days=MAXLATEDAYS)

    # TODO: Refactor out name and semester (no hard coding)
    course = next(
        (
            c for c in g.classes if c.role == "instructor" and
            c.name == "Comp 15" and c.semester == "Fall 2020"
        ), None
    )

    if not course:
        raise ValueError("Don't have access to course on Gradescope")

    assignment = next((a for a in course.assignments if a.name == assign), None)

    if not assignment:
        assignment = course.create_assignment(
            title=assign,
            totalPoints=0,
            releaseDate=hideUntil,
            dueDate=hideUntil,
            manualGrading=True,
            memoryLimit=6144,
            autograderTimeout=600
        )

    return course.id, assignment.id


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Helps you set up an assignment'
    )
    requiredArgs = parser.add_argument_group('required arguments')
    requiredArgs.add_argument(
        '-a', required=True, dest='assign', help='Assignment name e.g. hw1'
    )
    requiredArgs.add_argument(
        '-d',
        required=True,
        dest='duedate',
        help='Date in form of MM/DD e.g. 12/25',
        type=verifyDateTime("%m/%d")
    )
    requiredArgs.add_argument(
        '-t',
        required=True,
        dest='duetime',
        help='Time in form of HH:MM e.g. 15:00',
        type=verifyDateTime("%H:%M")
    )
    group = parser.add_mutually_exclusive_group(required=False)
    group.add_argument('--minfiles', help="Minimum number of files required")
    group.add_argument(
        '--numfiles', dest='files', help="Number of files required"
    )
    parser.add_argument(
        '--status',
        help="Status of assignment. Default is 'off'",
        default='off',
        choices=[
            "on",
            "off",
        ]
    )
    parser.add_argument('reqFiles', metavar='files', nargs='*',\
                        help='Names of required files.')
    parser.add_argument('-ns', dest='submissions', default='5',\
                        help='Number of submissions allowed per student. Default: 5.')

    main(**vars(parser.parse_args()))
