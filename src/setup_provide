#!/usr/bin/python3

import argparse
import os
import re
import shutil
import subprocess
from datetime import datetime
from itertools import chain
from pathlib import Path
from time import sleep

COURSE = 15
BASEDIR = Path(f"/comp/{COURSE}/grading")
ASSIGN_CONF = BASEDIR / "assignments.conf"
GROUP = "grade15"


def main(
    assign, duedate, duetime, minfiles, files, reqFiles, submissions, status
):
    userConfig = {
        k: v
        for k, v in locals().items() if v is not None and k != "reqFiles"
    }
    os.umask(0o002)

    TESTSET = BASEDIR / f"screening/testsets/{assign}"
    EXCEPTIONS = BASEDIR / f"{assign}/exceptions.conf"

    foundConfig, (start, end) = find_assignment(assign)
    newConfig = {
        **{
            "prepare": "screening/bin/check_files"
        },
        **foundConfig,
        **userConfig
    }

    add_assignment(newConfig, start, end)
    launch_editor(ASSIGN_CONF, start)

    setupLegacyFolders(assign)
    create_testset(assign, reqFiles)
    launch_editor(TESTSET)
    prozac(COURSE, assign)
    add_exception(EXCEPTIONS)


def add_exception(EXCEPTIONS):
    """
    adds exception for mkorma01 account to allow for testing
    """
    with open(f"{EXCEPTIONS}", "a") as f:
        f.write(
            "login=mkorma01 status=on duedate=12/25 duetime=11:59pm submissions=10000 "
        )


def create_testset(assign, files):
    """
    copies setup_testset to the assignment folder and makes the appropriate edits
    adding in required files passed in by user and updating the assignment name
    """
    new_testset = BASEDIR / f"screening/testsets/{assign}"

    shutil.copy2(BASEDIR / "tests/setup-provide/bin/setup_testset", new_testset)
    shutil.chown(new_testset, group=GROUP)
    new_testset.chmod(0o770)
    # edit testset
    filenames = ' '.join(files)
    subprocess.run(["sed", "-i", f"s/ASSIGN_NAME/{assign}/g", f"{new_testset}"])
    subprocess.run(
        ["sed", "-i", f"s/REQUIRED_FILES/{filenames}/g", f"{new_testset}"]
    )


def getEntireConfig(fileIterator):
    """
        Grabs all lines from iterator until first non continued line
        returns (endingLineno, lines)
    """
    lineno, line = next(fileIterator)
    if not line.endswith("\\\n"):
        return lineno, line.rstrip()
    end, suffix = getEntireConfig(fileIterator)
    return end, line + suffix


def find_assignment(assign):
    """
        Finds the assignment if it exists and returns the config.
        Always returns last found assignment. 
        Ex. in assignment.conf:
            assign=hw4 submissions=5 duedate=3/11
            assign=hw4 submissions=9999 duedate=12/25 <--- returned

        Returns (assignDict, (    start,       end))   if found
                (        {}, (eofLineno, eofLineno))   if not found
    """
    found_assignment = None
    pattern = "assign=" + assign
    with open(ASSIGN_CONF) as f:
        fileIter = enumerate(f, 1)
        for lineNum, line in fileIter:
            if line.isspace():
                continue

            endNum, conf = getEntireConfig(chain([(lineNum, line)], fileIter))

            if re.search(r'\b' + pattern + r'\b', conf):
                found_assignment = (config2dict(conf), (lineNum, endNum))

    eofNum = max(lineNum, endNum) + 1
    return found_assignment if found_assignment else ({}, (eofNum, eofNum))


def config2dict(config):
    config = config.replace("\\\n", " ")
    return dict(field.split("=", 1) for field in config.split())


def dict2config(configDict):
    updated_config = ""
    for field, value in sorted(configDict.items(), key=lambda x: x[0]):
        if field == "prepare":
            updated_config += "\\\n\t"
        updated_config += field + "=" + value + " "
    return updated_config


def launch_editor(path, line_num=0):
    """
    launches vim and has user verify and save file.
    """
    print(
        f"Launching Vim on file: {path}. Verify edits, then save and quit to continue."
    )
    sleep(3)
    subprocess.run(["vim", f"+{line_num}", path])


def add_assignment(configDict, start=None, end=None):
    """
    adds the assignment to assignments.conf
    """
    config = dict2config(configDict)

    # Assignment exists, so we are overwritting with our new config
    with ASSIGN_CONF.open() as f:
        data = f.readlines()
    with ASSIGN_CONF.open("w") as f:
        f.writelines(data[0:start - 1])
        # Add newline if file doesn't end with a newline
        if start > len(data) and not data[-1].endswith("\n"):
            f.write("\n")
        f.write(config + "\n")
        f.writelines(data[end:])


def setupLegacyFolders(assign):
    """
        Sets up a list of folders that are used by 
        /comp/15/grading/gtools/grade

        Not currently in use, but set up as a fallback
    """
    testdir = BASEDIR / f'tests/{assign}'
    for x in ["bin", "copy", "cpp", "input", "output", "makefile"]:
        (testdir / x).mkdir(parents=True, exist_ok=True)
        shutil.chown(testdir / x, group=GROUP)
    shutil.chown(testdir, group=GROUP)


def prozac(course, assign):
    """
        Runs prozac, which sets up /comp/15/grading/HWID and assures
        correct permissions
    """
    subprocess.run(["prozac", f"comp{course}", assign])


def verifyDateTime(dtFormat):
    def verifier(value):
        try:
            datetime.strptime(value, dtFormat)
            return value
        except ValueError:
            pass
        raise argparse.ArgumentTypeError(
            f"{value} doesn't match format {dtFormat}"
        )

    return verifier


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Helps you set up an assignment'
    )
    requiredArgs = parser.add_argument_group('required arguments')
    requiredArgs.add_argument(
        '-a', required=True, dest='assign', help='Assignment name e.g. hw1'
    )
    requiredArgs.add_argument(
        '-d',
        required=True,
        dest='duedate',
        help='Date in form of MM/DD e.g. 12/25',
        type=verifyDateTime("%m/%d")
    )
    requiredArgs.add_argument(
        '-t',
        required=True,
        dest='duetime',
        help='Time in form of HH:MM e.g. 15:00',
        type=verifyDateTime("%H:%M")
    )
    group = parser.add_mutually_exclusive_group(required=False)
    group.add_argument('--minfiles', help="Minimum number of files required")
    group.add_argument(
        '--numfiles', dest='files', help="Number of files required"
    )
    parser.add_argument(
        '--status',
        help="Status of assignment. Default is 'off'",
        default='off',
        choices=[
            "on",
            "off",
        ]
    )
    parser.add_argument('reqFiles', metavar='files', nargs='*',\
                        help='Names of required files.')
    parser.add_argument('-ns', dest='submissions', default='5',\
                        help='Number of submissions allowed per student. Default: 5.')

    main(**vars(parser.parse_args()))
